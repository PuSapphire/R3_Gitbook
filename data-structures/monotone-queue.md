---
description: O(n)的固定區間極值
---

我們先來看下面這題：

> 給一個長度為 $$N$$ 的陣列，請求出他所有長度為 $$K$$ 的連續區段的最大值。

什麼意思? 比如說，給了一個陣列 `1 7 2 9 5 8 3 7 1 6` 以及一個`K`值`3`，
你要輸出的就是第一到三個數字、第二到四、三到六... 八到十，這些區段的數字最大值。\
以上面的陣列作為範例，你就要輸出`7 9 9 9 8 8 7 7`。

最直觀的辦法，我們可以用巢狀迴圈對每個區間都進行檢查，不過這樣的時間複雜度會是 $$O(NK)$$ ，在測資較大的情況下就會`TLE`。

除此之外，我們還可以利用樹狀結構來解決。

例如：利用`STL`中的`map`，將元素的位置當成`key`、值當成`value`，並且令其依照`value`排序
(自己寫一個`cmp`函式告訴`map`怎麼排——`map`會將`key, value`綁成`pair`儲存)。
這樣，每次操作即刪除超出範圍的值，輸出`map.begin()->second`(假設由大排到小)，並插入新的值。
插入、刪除的動作都是 $$O(\log k)$$，輸出僅需 $$O(1)$$，總共有 $$N$$ 個元素，整體的時間複雜度為 $$O(n \log k)$$。

然而，我們還有更好的方法，能達到時間複雜度 $$O(N)$$。

### 核心概念

這個題目看起來很像**滑窗sliding window**，但卻有一個難點在這裡：
如果最大值超出範圍了，我們必須知道「第二大值」是多少，並把它變成新的答案。如果第二大值也超出範圍了，就必須知道第三大值，再來是第四大值、第五大值...

這要怎麼做? 我們先把這個想法放一邊，轉過頭來看一個情況。\
假設這是一個陣列的某一部分:

$$
...,\ 6,\ 3,\ 9,\ 7,\ ...
$$

假設我們算到 $$3$$ 時目前的固定區間最大值仍都是 $$6$$，而此時看到數字 $$9$$，會發生什麼事情?\
接下來的滑窗，如果包含這個 $$6$$，那麼必定也包含了 $$9$$。而且，$$6$$ 這個數字，會先比 $$9$$ 還要早超出滑窗的範圍。\
因此，當我們遇到 $$9$$ 之後，固定區間最大值就不可能是 $$6$$ 了。

遇到 $$9$$ 之後，接下來遇到的 $$7$$ 呢?\
雖然 $$7$$ 比 $$9$$ 還要小，但 $$7$$ 卻會比 $$9$$ 還要晚超出滑窗範圍，
所以 $$7$$ 仍然有可能在未來變成新的固定區間最大值。

第一種情況，$$6$$ 這個數字顯然完全被 $$9$$ 給淘汰掉了——不論如何，接下來他必定不是最大值。也就是說，這個時候 $$6$$ 已經不需要紀錄了。

第二種情況，$$7$$ 雖然比 $$9$$ 小，但出現在比較後面，所以仍有可能在之後變成最大值。也就是說，$$7$$ 即便目前不是最大，仍然須被記錄;
等到 $$9$$ 超出滑窗範圍後，$$7$$ 可能就會成為新的最大值。

我們就用上面這兩個想法，結合`STL`中的`deque`——也就是頭尾都能`pop()`的`queue`，就能在 $$O(n)$$ 內的時間解決這題了!

### 實作細節

{% tabs %}
{% tab title="C++" %}
```cpp
#include <deque>

int n = 105, k = 3; //k是固定區間長度
int array[n]; //假設陣列裡已經有數字了

//「單調列隊」(Monotone queue)：列隊中的元素呈現遞增或遞減。
// 常用於解決「陣列所有固定區間求極值」的問題，均攤下時間複雜度為 O(n)
// 在以下程式碼中，monoqu永遠呈現前面的值大、後面值小的情況。
deque<pair<int,int>> monoqu; //pair儲存{值，位置}

for (int i=0; i<n; ++i) {
  //每次新讀取一個值 array[i]，
  //它的陣列位置必定比所有在queue裡元素的陣列位置還要後面。
  //因此，位於這個值之前，而又較小的值，必然不會再被使用，
  //所以將這些「必定較差」的值淘汰掉。

  //除此之外，還要再將超出滑窗的值刪除。
  
  //記得在刪除之前檢查deque是不是空的。
  
  //刪除所有超出滑窗範圍的值。
  while (!monoqu.empty() && monoqu.front().second < i-k+1)
    monoqu.pop_front();

  //將出現較早、值較小的「必定較差」的數淘汰。→情況1
  //淘汰完後，deque可能就空了(array[i]比之前所有值都大)，
  //或者還會剩下一些值(都比array[i]還要大)。 →情況2
  while (!monoqu.empty() && monoqu.back().first < array[i])
    monoqu.pop_back();
	  
  //將新的值推到列隊推進來。
    monoqu.push_back({array[i], i});
  
  cout << monoqu.front().first << ' ';
}
```
為什麼是 $$O(n)$$ 呢? 可以觀察到，每個元素只會被插入一次、刪除一次。
{% endtab %}
{% endtabs %}
