---
description: '"小小的測驗" Python篇'
---

# 表單題目 Python題解

## Py 0：字串比大小

```python
#執行以下程式碼會輸出?
s1 = "Purple"
s2 = "Red"
print(s1 > s2)
```

**答：False**

相信大家對數字的比大小不會有甚麼疑惑。但字串要怎麼比大小？\
字串比大小的方式，其實很直觀：利用**字典序(Lexicographical Order)**來進行比較。\
什麼意思？就是一一對比字元，看哪個在**字典裡先出現，如果兩個字完全相同再對下一組字元進行比較**。\
以下舉幾個例子來進行解釋。

`'A' vs 'B'`\
`'A'`出現在`'B'`前面，因此`'A'<'B'`。

`'Z' vs 'a'`\
**大寫的字母比小寫的小**，`'Z'<'a'`。

`"Apple" vs "Applf"`\
字串前4個字(`"Appl"`)完全一樣，還無法判斷。 \
第五個字，`'e'`出現在`'f'`前，因此`"Apple"<"Applf"`。

`"abcdef" vs "abc"`\
`'a'`、`'b'`、`'c'`都相等，但接下來`"abc"`已經沒有字可以比了。 \
此時**較長的那個比較大**。因此`"abcdef">"abc"`。

`"Za" vs "Ep1kG4M5R"`\
比較第一個字，`'Z'>'E'`，因此`"Za">"Ep1kG4M5R"`

更進一步講，如果我們想要「對一個字串進行排序」，通常就是用字典序當作排序標準。

想知道更嚴謹的定義方式，則可以參考[ASCII表](https://en.cppreference.com/w/cpp/language/ascii)的`dec`欄位。\
作法是將每個字元轉換成ASCII對應的數值進行比較。

## Py 1：Python的陣列特性

```python
#執行以下程式碼會輸出?
x = [i**2 for i in range(1, 5)]

y = x

y += [2147682647]

print( x )
```

**答：`[1, 4, 9, 16, 2147683647]`**

第一行程式是Python中非常非常重要的一個語法，十分強大的同時讀起來也十分簡單。\
具體可以參考自修園地的**列表推導式**`List Comprehension`(今後會更新)。\
即便不曾寫過看過，Python語法簡單易懂的特性，應該能讓你從字面上就去理解它。\
若是如此，這部分只要知道Python的`range(a, b)`是包含`a`而不含`b`的即可。

但當我們繼續往下看...... \
對`y`進行的改變影響了`x`。 \
為什麼會這樣？這裡就必須談談Python的**可變型別(Mutable Objects)**。

Python的可變型別不多，只有`list`、`set`、`dict`跟`bytearray`。 \
其中，`list`是最常用到的，也就是`陣列[ ]`。 \
為了解釋可變型別，以下是一個概念類似的情景。

### 稱呼與實際物質的差別

![孔子聖蹟圖（取自維基百科）](../.gitbook/assets/confucious.png)

此人姓名**孔丘**，字**仲尼**，後人尊其為**孔子**、**孔夫子**，又尊稱「**至聖先師**」、「**萬世師表**」。 \
孔子、仲尼、至聖先師等等，**指的都是同一個人**。 \
世界上**沒有多個孔丘**，然後分別被叫做孔子、仲尼以及至聖先師。

因此，當歷史學家發現「孔子提倡『有教無類』、『因材施教』」時： \
代表「仲尼」也提倡有教無類因材施教、「至聖先師」也提倡有教無類因材施教。 \
因為這些都只是稱謂，而實際上人只有一位。\
**同一個人可以同時擁有多個稱謂**。

```python
x = [1, 4, 9, 16]
y = x
z = y
```

當我們這樣宣告時，並沒有出現多個`[1, 4, 9, 16]`，而是類似這樣的效果： \
`x(孔丘) = [1, 4, 9, 16](孔丘這個名字代表的「人」本身)`\
`y(孔子) = x(孔丘)`\
`z(至聖先師) = y(孔子)`\
因此當我們對其中的任何一個變數進行操作時，其餘的變數也會受到影響。\
就如同，假設哪天考古學家發現孔子會跳KTV，代表孔丘、萬世師表也會跳KTV。\
**因為從始至終就只有一個陣列，而x y z只是它不同的稱謂。**\
Python中的list如果想要複製，是得刻意使用`.copy()`函式的。但要注意複製這個動作複雜度為`O(n)`，得小心。

## **Py 挑戰題：遞迴函式**

```python
#若要形容以下程式碼，最符合的敘述是?
def work(dat, l, r):
    if (l == r):
        return
    m = (l + r) // 2
    work(dat, l, m)
    work(dat, m+1, r)
    i = l
    j = m+1
    tmp = []
    while i <= m:
        while j <= r and dat[j] < dat[i]:
            tmp += [dat[j]]
            j += 1
        tmp += dat[i]
        i += 1
    for i in range(l, j):
        dat[i] = tmp[i-l]
```

**答：遞迴函式**

遞迴函式並不複雜。\
**遞迴函式**，就是在**定義中包含自己的函式**。\
其它常有的特性，還有在函式裡**通常會有**一個用來**結束遞迴（從而避免無限遞迴）的基準狀態**。\
以下舉幾個例子。

```python
#計算費式數列
def fib(n):
    if n == 1 or n == 2: #基準狀態：費式數列的1、2項 = 1
        return 1
    else:
        return fib(n-1) + fib(n-2) #否則F(n) = F(n-1) + F(n-2)
        
#計算階乘
def fact(n):
    if n == 1: #基準狀態：1! = 1
        return 1
    else:
        return n * fact(n-1) #否則 n! = n * (n-1)!
```

回到題目程式碼，其中的第6、7行中：\
`work(dat, l, m) `\
`work(dat, m+1, r)`\
便是「定義中包含自己」。又在第3行：\
`if l == r:`\
`    return`\
便是這個遞迴函式的基準狀態。

P. S：其實這段程式碼是一個非常經典的演算法。
