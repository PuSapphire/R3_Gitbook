---
description: Binary Exponentiation
---

# 快速冪

### 為什麼要「快速冪」?

我們都知道 $$a^b$$ 就是 $$a$$ 乘以自己總計 $$b$$ 次，然而若僅是這樣依照定義去實作次方操作，時間複雜度就為 $$O(b)$$ ，這樣對於較大的 $$b$$ 顯然十分的沒有效率! 
況且，乘法這個操作在數字大的情況下也會相較於數字小的情況慢很多，即便不影響複雜度，乘的次數多了，導致數字變大，也會使常數變大許多。

另外，次方操作容易生成極大的數，因此常常對解答取模——也就是取餘數`%`。對於 $$a^b\bmod m$$ 的計算，先算出 $$a^b$$ 再取模也令人感覺十分沒有效率——中途的記憶體耗費十分驚人。

### 快速冪的核心概念

由指數律，我們知道次方運算有以下性質: $$a^{2b} = (a^2)^b$$ 。也就是說，如果我們的次方是偶數，那麼可以藉由將底數變成底數平方，而將所需的乘法運算數量砍半!

但如果次方是奇數怎麼辦呢? 又由指數律，有這樣的性質: $$a^{b+c} = a^b \times a^c$$ 。
假設 $$b+c$$ 是一個奇數，那麼如果設 $$c = 1$$ 將其提出變成 $$a^1 \times a^b$$ ，此時的 $$b$$ 就會是一個偶數，就能利用上面的方法對半切了!

而模運算呢? 對於模運算，有這樣的性質: $$a \times b \bmod m \equiv (a \bmod m) \times (b \bmod m) \bmod m$$ 。
因此，我們能在每個步驟都取模，這樣就能避免數字變得極大，也在過程中讓記憶體用量、時間用量都被優化了。

這樣的概念被稱作**快速冪(binary exponentiation)**，或是平方取冪(exponentiating by squaring)，可以將次方運算的時間複雜度從 $$O(n)$$ 壓到只剩下 $$O(\log n)$$ !

### 實作細節

快速冪就兩種情形，分成了次方是偶數、次方是奇數的情形。如果次方等於零就不用繼續乘了，因為任何數的零次方都是一。

次方是偶數，則將底數改為平方，並將次方對半砍。

次方是奇數，要將其拆成 $$a \times a^b$$ ，這可以怎麼存呢? 不妨額外開一個`res`變數，用於儲存將這些被提取出來的 $$a$$ 相乘的結果。
實際上，經過一定運算後，次方最後一定會變為 `1` (假設次方初始值大於`0`)，此時`res`會乘上最後一次的`a`，因此最後`res`實際上就是我們要的答案。原因大家可以自己想看看。

{% hint style="info" %}
實際上，`Python`中有現成的`pow(a, b, m)`可以使用，但為了示範，還是附上`Python`程式碼。\
實際操作時，使用`pow()`既不用自己寫，還會比較快。有現成的就用現成的。
{% endhint %}

{% tabs %}
{% tab title="C++" %}
```cpp
long long binary_exponentiation(long long a, long long b, long long m) {
    long long res = 1;
    while (b > 0) { //計算直到次方=0
        if (b % 2 == 1) { //次方是奇數，提出一個a，讓b變成偶數
            res = res*a % m; //利用模運算的性質
            b--; //實際上不用這行，因為除二的時候這個1就會自動被刪掉了。
        }
        a = a*a % m;
        b /= 2;
    }
    return res;
}
```
{% endtab %}

{% tab title="Python" %}
```python
def binary_exponentiation(a, b, m):
    res = 1
    while b > 0: #計算直到次方=0
        if b % 2 == 1: #次方是奇數，提出一個a，讓b變成偶數
            res = res*a % m #利用模運算的性質
            b -= 1 #實際上不用這行，因為除二的時候這個1就會自動被刪掉了。
        a = a*a % m
        b //= 2
    return res
```
{% endtab %}
{% endtabs %}
